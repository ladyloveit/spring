## 深入理解IoC(控制反转)和DI(依赖注入)

我们经常会听说IoC，也就是Inversion of Controller，控制反转。事实上，IoC并不是一个新鲜的概念，最早可能是在1988年，由Ralph E. Johnson和Brian Foote在论文[Designing Reusable Classes](http://www.laputan.org/drc/drc.html)中提出。IoC从字面上来说有两个内容，一个是控制，一个是反转。那么什么是控制呢？又是怎样反转的呢？

为了更好的理解，我们用个实例来说明吧。下面的程序有一个`MovieLister`类，它含有一个`moviesDirectedBy`方法来取得某个导演的电影列表。

如果采用传统的编程：

MovieLister.java

	package com.ladyloveit;
	public class MovieLister {

		private MovieFinder movieFinder；

		public MovieLister(){
			movieFinder = new TxtFileMovieFinder("movies.txt");
		}
		
		public Movie[] moviesDirectedBy(String director) {

			List allMovies = movieFinder.findAll();

			for (Iterator it = allMovies.iterator(); it.hasNext();) {
				Movie movie = (Movie) it.next();
				if (!movie.getDirector().equals(director)) it.remove();
			}
			return (Movie[]) allMovies.toArray(new Movie[allMovies.size()]);
		}
	}

此外提供一个`MovieFinder`接口：

MovieFinder.java

	package com.ladyloveit;
	public interface MovieFinder {
		List findAll();
	}

那么`MovieFinder`接口有很多不同的实现，譬如用于读取txt文件的`TxtFileMovieFinder`，还可能读取储存在数据库中的数据的`DatabaseMovieFinder`，还有可能有读取储存在Xls文件中的数据的`XlsFileMovieFinder`。它们都实现了`MovieFinder`接口，并有各自的`findAll()`实现。

看起来不错吧，你可以修改构造器中的`movieFinder = new TxtFileMovieFinder("movies.txt");`，以选择合适的实现。

但现在问题来了，MovieLister既依赖于接口`MovieFinder`，又同时依赖实现`TxtFileMovieFinder`，因为它需要在编译阶段就确定使用哪种实现，这样显然缺乏灵活性。如果我们既需要实现从txt文件中读取数据，又需要从数据库中读取数据，那么我们是不是要实现两个MovieLister呢：一个TxtMovieLister，一个DatabaseMovieLister？

TxtMovieLister.java:

	package com.ladyloveit;
	public class TxtMovieLister {

		private MovieFinder movieFinder；

		public MovieLister(){
			movieFinder = new TxtFileMovieFinder("movies.txt");
		}
		
		public Movie[] moviesDirectedBy(String director) {

			List allMovies = movieFinder.findAll();

			for (Iterator it = allMovies.iterator(); it.hasNext();) {
				Movie movie = (Movie) it.next();
				if (!movie.getDirector().equals(director)) it.remove();
			}
			return (Movie[]) allMovies.toArray(new Movie[allMovies.size()]);
		}
	}

DatabaseMovieLister.java:
	
	package com.ladyloveit;
	public class TxtMovieLister {

		private MovieFinder movieFinder；

		public MovieLister(){
			movieFinder = new DatabaseMovieFinder("myDatabase");
		}
		
		public Movie[] moviesDirectedBy(String director) {

			List allMovies = movieFinder.findAll();

			for (Iterator it = allMovies.iterator(); it.hasNext();) {
				Movie movie = (Movie) it.next();
				if (!movie.getDirector().equals(director)) it.remove();
			}
			return (Movie[]) allMovies.toArray(new Movie[allMovies.size()]);
		}
	}

这样显然很多余。

如果我们能让`MovieLister`只依赖`MovieFinder`接口，换句话说就是将调用类`MovieLister`对于选择哪个具体类的控制权从调用类中移除，转交给第三方决定，所以实现了“控制”的“反转”。这也就是控制反转的概念。但这个说法太抽象，所以[Martin Fowler](http://martinfowler.com/)在2004年在他的论文[Inversion of Control Containers and the Dependency Injection pattern](http://martinfowler.com/articles/injection.html)中提出了对IoC更确切的实现方法：依赖注入(Dependency Injection）：移除调用类(`MovieLister`)对某一接口(`MovieFinder`)的具体实现类(`TxtFileMovieFinder`, `DatabaseMovieFinder`等)的依赖。显然“依赖注入”相比较于“控制反转”更简单明了，更容易理解。

> 另外对于控制反转还有另外一种实现: [service locator](http://martinfowler.com/articles/injection.html#UsingAServiceLocator)。但由于Spring是采用依赖注入来实现的，所以service locator暂时不在我的讨论范围之内。

Spring正是采用了依赖注入的框架。Spring支持的注入方式有两种：setter injection和constructor injection。关于注入的这两种方式请查看[后续章节]()。

我们这里仅仅用`setter injection`作个简单的实例说明：

MovieLister.java:

	package com.ladyloveit;
	public class MovieLister {

		private MovieFinder movieFinder；

		public MovieLister(){

		}

		public void setMovieFinder(MovieFinder movieFinder){
			this.movieFinder = movieFinder；
		}
		
		public Movie[] moviesDirectedBy(String director) {

			List allMovies = movieFinder.findAll();

			for (Iterator it = allMovies.iterator(); it.hasNext();) {
				Movie movie = (Movie) it.next();
				if (!movie.getDirector().equals(director)) it.remove();
			}
			return (Movie[]) allMovies.toArray(new Movie[allMovies.size()]);
		}
	}


TxtFileMovieFinder.java:

	package com.ladyloveit;
	public class TxtFileMovieFinder{
		
		String filename;

	    public void setFilename(String filename) {
	        this.filename = filename;
	    }
	}

好了，接下来还剩一个步骤，就是要告诉Spring在运行时对象之间的依赖关系，以便Spring将对象装配起来。这里我们暂且用最简单的方法，使用一个XML的配置文件：

	<beans ...>
        <bean id="MovieLister" class="com.ladyloveit.MovieLister">
            <property name="movieFinder" ref="MovieFinder" />
        </bean>
        <bean id="MovieFinder" class="com.ladyloveit.TxtFileMovieFinder">
            <property name="filename" value="movies.txt" />
        </bean>
    </beans>

## TODO

## 传统编程和IoC的对比

- 传统编程：决定使用哪个具体的实现类的控制权在调用类本身，在编译阶段就确定了。
- IoC模式：控制权交给了容器，在运行的时候才由容器决定将具体的实现动态的“注入”到调用类的对象中。