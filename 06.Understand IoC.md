## 深入理解IoC(控制反转)和DI(依赖注入)

我们经常会听说IoC，也就是Inversion of Controller，控制反转。事实上，IoC并不是一个新鲜的概念，最早可能是在1988年，由Ralph E. Johnson和Brian Foote在论文[Designing Reusable Classes](http://www.laputan.org/drc/drc.html)中提出。IoC从字面上来说有两个内容，一个是控制，一个是反转。那么什么是控制呢？又是怎样反转的呢？

为了更好的理解，我们用个实例来说明吧。下面的程序有一个`MovieLister`类，它含有一个`moviesDirectedBy`方法来取得某个导演的电影列表。注意，以下的代码都是截取的片段，并不完整。

如果采用传统的编程：

MovieLister.java

	public class MovieLister {

		private MovieFinder movieFinder；

		public MovieLister(){
			movieFinder = new TxtFileMovieFinder("movies.txt");
		}
		
		public Movie[] moviesDirectedBy(String director) {

			List<Movie> allMovies = movieFinder.findAll();

			Iterator<Movie> it = allMovies.iterator();
			while (it.hasNext()) {
				Movie movie = it.next();
				if (!movie.getDirector().equals(director)) {
					it.remove();
				}
			}
			return (Movie[]) allMovies.toArray(new Movie[allMovies.size()]);
		}

		...
	}

此外提供一个`MovieFinder`接口：

MovieFinder.java

	public interface MovieFinder {
		List<Movie> findAll();
	}

那么`MovieFinder`接口有很多不同的实现，譬如用于读取txt文件的`TxtFileMovieFinder`，还可能读取储存在数据库中的数据的`DatabaseMovieFinder`，还有可能有读取储存在Xls文件中的数据的`XlsFileMovieFinder`。它们都实现了`MovieFinder`接口，并有各自的`findAll()`实现。

![传统方法](06.Understand%20IoC/Traditional-UML.png)

看起来不错吧，你可以修改构造器中的`movieFinder = new TxtFileMovieFinder("movies.txt");`，以选择合适的实现。

但现在问题来了，MovieLister既依赖于接口`MovieFinder`，又同时依赖实现`TxtFileMovieFinder`，因为它需要在编译阶段就确定使用哪种实现，这样显然缺乏灵活性。如果我们既需要实现从txt文件中读取数据，又需要从数据库中读取数据，那么我们是不是要实现两个MovieLister呢：一个TxtMovieLister，一个DatabaseMovieLister？就像这样：

TxtMovieLister.java:

	public class TxtMovieLister {

		private MovieFinder movieFinder；

		public MovieLister(){
			movieFinder = new TxtFileMovieFinder("movies.txt");
		}
		
		public Movie[] moviesDirectedBy(String director) {
			
			// 同上面的代码一样
			...
		}

		...
	}

DatabaseMovieLister.java:

	public class DatabaseMovieLister {

		private MovieFinder movieFinder；

		public MovieLister(){
			movieFinder = new DatabaseMovieFinder("myDatabase");
		}
		
		public Movie[] moviesDirectedBy(String director) {

			// 同上面的代码一样
			...
		}

		...
	}

这样做显然很有很多重复的代码。

如果我们能让`MovieLister`只依赖`MovieFinder`接口，而不依赖具体的实现类，不是就解决了问题吗？换句话说就是将调用类`MovieLister`对于选择哪个具体类的控制权从调用类中移除，转交给第三方决定，实现了“控制”的“反转”，这也就是我们所说的IoC。

但控制反转这个说法太抽象，所以[Martin Fowler](http://martinfowler.com/)在2004年在他的论文[Inversion of Control Containers and the Dependency Injection pattern](http://martinfowler.com/articles/injection.html)中提出了对IoC更确切的实现方法：依赖注入(Dependency Injection）。在我们的例子中，调用类(`MovieLister`)依赖于某一接口(`MovieFinder`)，我们将调用类对这一接口的具体实现类(`TxtFileMovieFinder`, `DatabaseMovieFinder`等)的依赖从调用类`MovieLister`中分离出来，让第三方(容器)在运行时将具体的实现注入到调用类的对象中去。显然“依赖注入”相比较于“控制反转”更简单明了，更容易理解。

> 此外，对于控制反转还有另外一种实现: [service locator](http://martinfowler.com/articles/injection.html#UsingAServiceLocator)。但由于Spring是采用依赖注入来实现的，所以service locator暂时不在我的讨论范围之内。

Spring的核心就是依赖注入。Spring支持的注入方式主要有两种：setter注入(setter injection)和构造器注入(constructor injection)。关于注入的这这两种方式请查看[后续章节]()。

我们这里仅仅用`setter注入`作个简单的实例说明：

MovieLister.java:

	package com.ladyloveit;

	public class MovieLister {

		private MovieFinder movieFinder；

		public MovieLister(){

		}

		public void setMovieFinder(MovieFinder movieFinder){
			this.movieFinder = movieFinder；
		}
		
		public Movie[] moviesDirectedBy(String director) {

			// 同上面的代码一样
			...
		}

		...
	}


TxtFileMovieFinder.java:

	package com.ladyloveit;

	public class TxtFileMovieFinder{
		
		String fileName;

	    public void setFileName(String fileName) {
	        this.fileName = fileName;
	    }

	    ...
	}

好了，接下来还剩一个步骤，就是要告诉Spring对象之间的依赖关系，以便Spring将对象装配起来。这里我们暂且用最简单的方法，使用一个XML的配置文件：

	<beans ...>
		<bean id="MovieLister" class="com.ladyloveit.MovieLister">
			<property name="movieFinder" ref="MovieFinder" />
		</bean>

		<bean id="MovieFinder" class="com.ladyloveit.TxtFileMovieFinder">
			<property name="fileName" value="movies.txt" />
		</bean>
    </beans>

![依赖注入](06.Understand%20IoC/Dependency-Injection-UML.png)

如果还要增加读取数据库的实现，我们该怎么做呢？

DatabaseMovieFinder.java:

	package com.ladyloveit;

	public class DatabaseMovieFinder{
		
		String databaseName;

	    public void setDatabaseName(String databaseName) {
	        this.databaseName = databaseName;
	    }

	    ...
	}

然后在XML文件中加入相应的bean，修改以下bean的名称：

	<beans ...>
		<bean id="TxtFileMovieLister" class="com.ladyloveit.MovieLister">
			<property name="movieFinder" ref="TxtFileMovieFinder" />
		</bean>

		<bean id="TxtFileMovieFinder" class="com.ladyloveit.TxtFileMovieFinder">
			<property name="fileName" value="movies.txt" />
		</bean>

		<bean id="DatabaseMovieLister" class="com.ladyloveit.MovieLister">
			<property name="movieFinder" ref="DatabaseMovieFinder" />
		</bean>

		<bean id="DatabaseMovieFinder" class="com.ladyloveit.DatabaseMovieFinder">
			<property name="databaseName" value="myDatabase" />
		</bean>
    </beans>

## 传统编程和IoC的对比

- 传统编程：决定使用哪个具体的实现类的控制权在调用类本身，在编译阶段就确定了。
- IoC模式：控制权交给了容器，在运行的时候才由容器决定将具体的实现动态的“注入”到调用类的对象中。